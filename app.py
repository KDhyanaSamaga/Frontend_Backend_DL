import pathlib
# Fix for YOLOv5 checkpoints saved on POSIX (Linux) when loading on Windows
pathlib.PosixPath = pathlib.WindowsPath

from flask import Flask, render_template, request, jsonify
import torch
import cv2
import os
import numpy as np
import base64
import time
import requests
from werkzeug.utils import secure_filename

# ==========================
# CONFIGURATION
# ==========================

UPLOAD_FOLDER = "uploads"
OUTPUT_FOLDER = os.path.join("static", "outputs")
ALLOWED_IMAGE_EXTENSIONS = {"png", "jpg", "jpeg"}
ALLOWED_VIDEO_EXTENSIONS = {"mp4", "avi", "mov", "mkv"}

# Your Telegram details (rotate token later for safety)
TELEGRAM_BOT_TOKEN = "8450849961:AAFcZejoVCRaFIZ0GNSHWaV9f04MIt5A4RE"
TELEGRAM_CHAT_ID = "6547885190"

app = Flask(__name__, static_folder="static", template_folder="templates")
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

# ==========================
# LOAD YOLOv5 MODEL (best.pt)
# ==========================

# Path to your trained YOLOv5 weights
model_path = r"D:\UI\yolov5\best.pt"

# This uses the official YOLOv5 repo via PyTorch Hub
model = torch.hub.load(
    "ultralytics/yolov5",
    "custom",
    path=model_path,
    source="github",
    force_reload=False,  # set True once if your cache is broken
)
model.eval()


# ==========================
# HELPER FUNCTIONS
# ==========================

def allowed_file(filename):
    ext = filename.rsplit(".", 1)[1].lower() if "." in filename else ""
    return ext in ALLOWED_IMAGE_EXTENSIONS.union(ALLOWED_VIDEO_EXTENSIONS)


def is_image_file(filename):
    ext = filename.rsplit(".", 1)[1].lower() if "." in filename else ""
    return ext in ALLOWED_IMAGE_EXTENSIONS


def get_class_name(cls_idx: int) -> str:
    """Get readable class name from model.names."""
    names = model.names
    if isinstance(names, dict):
        return str(names.get(int(cls_idx), str(int(cls_idx))))
    try:
        return str(names[int(cls_idx)])
    except Exception:
        return str(int(cls_idx))


def send_telegram_alert(detections, output_url):
    """Send Telegram alert if any detection is present."""
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        return  # not configured

    unique_classes = sorted({det["class"] for det in detections})
    if not unique_classes:
        return  # nothing detected

    message = (
        "ðŸš¨ Wildlife Alert Detected!\n\n"
        f"Species detected: {', '.join(unique_classes)}\n"
        f"Output: {output_url}"
    )

    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    try:
        requests.post(url, data={"chat_id": TELEGRAM_CHAT_ID, "text": message})
    except Exception as e:
        print("Failed to send Telegram message:", e)


def draw_detections_on_image(image_bgr, results):
    """
    Draw bounding boxes and labels on a BGR image using YOLOv5 results.
    We don't use results.imgs or results.render() to avoid API issues.
    """
    annotated = image_bgr.copy()
    detections = []

    if not hasattr(results, "xyxy") or len(results.xyxy) == 0:
        return detections, annotated

    boxes = results.xyxy[0].cpu().numpy()  # [N, 6] -> x1,y1,x2,y2,conf,cls

    for row in boxes:
        x1, y1, x2, y2, conf, cls_idx = row
        cls_idx = int(cls_idx)
        class_name = get_class_name(cls_idx)

        detections.append(
            {
                "class": class_name,
                "confidence": round(float(conf), 3),
                "box": [
                    round(float(x1), 1),
                    round(float(y1), 1),
                    round(float(x2), 1),
                    round(float(y2), 1),
                ],
            }
        )

        # Draw box
        x1_i, y1_i, x2_i, y2_i = int(x1), int(y1), int(x2), int(y2)
        cv2.rectangle(annotated, (x1_i, y1_i), (x2_i, y2_i), (0, 255, 0), 2)

        label = f"{class_name} {conf:.2f}"
        cv2.putText(
            annotated,
            label,
            (x1_i, max(0, y1_i - 10)),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.6,
            (0, 255, 0),
            2,
            cv2.LINE_AA,
        )

    return detections, annotated


def run_inference_on_image(image_bgr, output_filename):
    """Run YOLOv5 on a single BGR image and save annotated result."""
    results = model(image_bgr)
    detections, annotated_bgr = draw_detections_on_image(image_bgr, results)

    output_path = os.path.join(OUTPUT_FOLDER, output_filename)
    cv2.imwrite(output_path, annotated_bgr)
    return detections, output_path


def run_inference_on_video(video_path, output_filename):
    """Run YOLOv5 on every frame of a video and save annotated video."""
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        raise RuntimeError("Could not open uploaded video")

    fps = cap.get(cv2.CAP_PROP_FPS) or 25
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

    output_path = os.path.join(OUTPUT_FOLDER, output_filename)
    fourcc = cv2.VideoWriter_fourcc(*"mp4v")
    writer = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

    all_detections = []

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        results = model(frame)
        detections, annotated_bgr = draw_detections_on_image(frame, results)
        all_detections.extend(detections)
        writer.write(annotated_bgr)

    cap.release()
    writer.release()

    # De-duplicate detections a bit
    unique_detections = {}
    for det in all_detections:
        key = (det["class"], tuple(det["box"]))
        if key not in unique_detections:
            unique_detections[key] = det

    return list(unique_detections.values()), output_path


def decode_webcam_image(data_url):
    """Decode a base64 dataURL from the browser to a BGR image."""
    if "," in data_url:
        _, encoded = data_url.split(",", 1)
    else:
        encoded = data_url
    img_bytes = base64.b64decode(encoded)
    img_array = np.frombuffer(img_bytes, dtype=np.uint8)
    img = cv2.imdecode(img_array, cv2.IMREAD_COLOR)
    return img


# ==========================
# ROUTES
# ==========================

@app.route("/")
def index():
    return render_template("index.html")


@app.route("/detect", methods=["POST"])
def detect():
    file = request.files.get("file")
    webcam_image = request.form.get("webcam_image")

    if not file and not webcam_image:
        return jsonify({"status": "error", "message": "No file or webcam image provided"}), 400

    timestamp = int(time.time() * 1000)

    detections = []
    output_rel_path = ""

    try:
        # From webcam snapshot
        if webcam_image:
            image_bgr = decode_webcam_image(webcam_image)
            if image_bgr is None:
                return jsonify({"status": "error", "message": "Invalid webcam image"}), 400

            output_filename = f"webcam_{timestamp}.jpg"
            detections, output_path = run_inference_on_image(image_bgr, output_filename)
            output_rel_path = "/" + output_path.replace("\\", "/")
            media_type = "image"

        # From uploaded file
        elif file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            ext = filename.rsplit(".", 1)[1].lower()
            temp_path = os.path.join(UPLOAD_FOLDER, f"{timestamp}_{filename}")
            file.save(temp_path)

            if ext in ALLOWED_IMAGE_EXTENSIONS:
                image_bgr = cv2.imread(temp_path)
                if image_bgr is None:
                    return jsonify({"status": "error", "message": "Could not read image file"}), 400

                output_filename = f"img_{timestamp}.jpg"
                detections, output_path = run_inference_on_image(image_bgr, output_filename)
                media_type = "image"
            else:
                output_filename = f"vid_{timestamp}.mp4"
                detections, output_path = run_inference_on_video(temp_path, output_filename)
                media_type = "video"

            output_rel_path = "/" + output_path.replace("\\", "/")

        else:
            return jsonify({"status": "error", "message": "File type not allowed"}), 400

        # Send Telegram if anything detected
        send_telegram_alert(detections, output_rel_path)

        return jsonify(
            {
                "status": "success",
                "type": media_type,
                "output_url": output_rel_path,
                "detections": detections,
            }
        )
    except Exception as e:
        print("Error during detection:", e)
        return jsonify({"status": "error", "message": str(e)}), 500


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
